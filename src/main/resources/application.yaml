spring:
  profiles:
    active: dev
  datasource:
    hikari:
      # Connection Pool Sizing (optimized for high concurrency)
      maximum-pool-size: 30        # Max connections (adjust based on PostgreSQL max_connections)
      minimum-idle: 10              # Keep 10 connections ready
      
      # Connection Lifecycle
      idle-timeout: 600000         # 10 minutes - close idle connections
      max-lifetime: 1800000        # 30 minutes - refresh connections to avoid issues
      connection-timeout: 20000    # 20 seconds - wait time for getting connection
      
      # Connection Testing
      connection-test-query: SELECT 1
      validation-timeout: 5000     # 5 seconds - timeout for connection validation
      
      # Leak Detection (helps identify connection leaks)
      leak-detection-threshold: 60000  # 1 minute - log possible connection leaks
      
      # Performance Optimizations
      auto-commit: true            # Ensure auto-commit is on (default)
      pool-name: OwMetaggHikariCP  # Custom name for monitoring
      
      # Connection Properties
      data-source-properties:
        cachePrepStmts: true       # Enable prepared statement caching
        prepStmtCacheSize: 250     # Number of prepared statements to cache
        prepStmtCacheSqlLimit: 2048  # Max length of SQL to cache
        useServerPrepStmts: true   # Use server-side prepared statements
        rewriteBatchedStatements: true  # Optimize batch inserts
        maintainTimeStats: false   # Disable time stats for performance
        
      # JMX Monitoring (enable metrics)
      register-mbeans: true        # Register JMX MBeans for monitoring
  jpa:
    hibernate:
      ddl-auto: update            # Changed from validate for development
    properties:
      hibernate:
        jdbc:
          batch_size: ${HIBERNATE_BATCH_SIZE:1000}
        order_inserts: true
        order_updates: true
    show-sql: false               # Set to true for debugging
  output:
    ansi:
      enabled: ALWAYS

# RabbitMQ Configuration
rabbitmq:
  queue:
    player-data: ${PLAYER_DATA_QUEUE:player.data.queue}
    statistics-trigger: ${STATS_TRIGGER_QUEUE:statistics.trigger.queue}
  exchange:
    name: ${RABBITMQ_EXCHANGE_NAME:overwatch.exchange}
  routing:
    player-data: ${PLAYER_DATA_ROUTING_KEY:player.data}
    statistics: ${STATS_ROUTING_KEY:statistics.trigger}
  concurrency: ${RABBITMQ_CONCURRENCY:5-10}

# OverFast API Configuration
overfast:
  api:
    base-url: ${OVERFAST_API_URL:https://overfast-api.tekrop.fr}
    rate-limit:
      requests-per-second: ${OVERFAST_RATE_LIMIT:10}
    timeout: ${OVERFAST_TIMEOUT_MS:30000}

# Statistics Processing
statistics:
  calculation:
    batch-size: ${STATS_BATCH_SIZE:1000}
    schedule:
      cron: ${STATS_SCHEDULE_CRON:0 0 */4 * * *}  # Every 4 hours

# Performance Settings
concurrency:
  rabbitmq: ${RABBITMQ_CONCURRENCY:5-10}
  statistics: ${STATISTICS_THREADS:3}

# Rate Limiting
security:
  rate-limit:
    requests-per-window: ${RATE_LIMIT_REQUESTS:100}
    window-minutes: ${RATE_LIMIT_WINDOW:1}
    cleanup-interval-ms: ${RATE_LIMIT_CLEANUP_MS:3600000}

# Logging
logging:
  level:
    com:
      yourname:
        overwatchstats:
          service:
            OverFastService: INFO
            RabbitService: INFO
            PlayerProcessingService: INFO
            StatisticsCalculationService: INFO
    org:
      springframework:
        amqp: INFO

# Server Settings
server:
  compression:
    enabled: true
    mime-types: application/json,text/plain
    min-response-size: 1024

---
# Development Profile
spring:
  config:
    activate:
      on-profile: "dev"
  application:
    name: overwatch-stats-backend-dev
  datasource:
    url: jdbc:postgresql://localhost:5433/owmetagg-database-dev
    username: postgres
    password: guest
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
  jpa:
    show-sql: true              # Show SQL in development
    hibernate:
      ddl-auto: update          # Auto-create tables in dev

# RabbitMQ Management
rabbitmq:
  management:
    api:
      url: http://localhost:15672/api
    username: guest
    password: guest

# CORS for frontend development
security:
  cors:
    allowed-origin: http://localhost:3000
    max-age-seconds: 3600

# Development-specific settings
overfast:
  api:
    rate-limit:
      requests-per-second: 5    # Be nice to OverFast API in dev

---
# Production Profile
spring:
  config:
    activate:
      on-profile: "prod"
  application:
    name: ${SPRING_APP_NAME:overwatch-stats-backend-prod}
  datasource:
    url: ${DATABASE_URL}
    username: ${DATABASE_USERNAME}
    password: ${DATABASE_PASSWORD}
    hikari:
      # Production overrides for higher scale
      maximum-pool-size: ${HIKARI_MAX_POOL_SIZE:50}  # Higher for production
      minimum-idle: ${HIKARI_MIN_IDLE:20}
      # PostgreSQL specific optimizations
      data-source-properties:
        # TCP keep-alive to prevent connection drops
        tcpKeepAlive: true
        # Statement timeout to prevent long-running queries
        statementTimeout: ${DB_STATEMENT_TIMEOUT:30000}  # 30 seconds default
  rabbitmq:
    host: ${RABBITMQ_HOST}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}
  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate        # Don't auto-modify prod schema

# Production RabbitMQ Management
rabbitmq:
  management:
    api:
      url: ${RABBITMQ_MANAGEMENT_URL}
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}

# Production security
security:
  cors:
    allowed-origin: ${CORS_ALLOWED_ORIGIN}
    max-age-seconds: ${CORS_MAX_AGE:3600}

# Production-specific settings
overfast:
  api:
    rate-limit:
      requests-per-second: ${OVERFAST_PROD_RATE_LIMIT:15}